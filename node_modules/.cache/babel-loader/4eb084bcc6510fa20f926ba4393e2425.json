{"ast":null,"code":"'use strict';\n\n(function () {\n  var CONSTANTS = {\n    HOLD_THRESHOLD: 8,\n    SCROLL_INTERVAL: 1000 / 60,\n    SCROLL_AREA_MAX: 50,\n    SCROLL_SPEED: 20\n  };\n  var downPos = null;\n  var mouseOffset = null;\n  var mouseDown = null;\n\n  function createOffsetStyles(event, props) {\n    var top = !props.lock || props.lock === 'horizontal' ? mouseOffset.clientY - mouseDown.clientY : 0;\n    var left = !props.lock || props.lock === 'vertical' ? mouseOffset.clientX - mouseDown.clientX : 0;\n    return 'translate(' + left + 'px,' + top + 'px)';\n  }\n\n  function getScrollOffsetX(rect, node) {\n    var positionInScrollArea;\n    var scrollLeft = node.scrollLeft;\n    var scrollWidth = node.scrollWidth;\n    var scrollAreaX = Math.min(rect.width / 3, CONSTANTS.SCROLL_AREA_MAX);\n\n    if (scrollLeft > 0 && mouseOffset.clientX <= rect.left + scrollAreaX) {\n      positionInScrollArea = Math.min(Math.abs(rect.left + scrollAreaX - mouseOffset.clientX), scrollAreaX);\n      return -positionInScrollArea / scrollAreaX * CONSTANTS.SCROLL_SPEED;\n    }\n\n    if (scrollLeft < scrollWidth - rect.width && mouseOffset.clientX >= rect.right - scrollAreaX) {\n      positionInScrollArea = Math.min(Math.abs(rect.right - scrollAreaX - mouseOffset.clientX), scrollAreaX);\n      return positionInScrollArea / scrollAreaX * CONSTANTS.SCROLL_SPEED;\n    }\n\n    return 0;\n  }\n\n  function getScrollOffsetY(rect, node) {\n    var positionInScrollArea;\n    var scrollTop = node.scrollTop;\n    var scrollHeight = node.scrollHeight;\n    var scrollAreaY = Math.min(rect.height / 3, CONSTANTS.SCROLL_AREA_MAX);\n\n    if (scrollTop > 0 && mouseOffset.clientY <= rect.top + scrollAreaY) {\n      positionInScrollArea = Math.min(Math.abs(rect.top + scrollAreaY - mouseOffset.clientY), scrollAreaY);\n      return -positionInScrollArea / scrollAreaY * CONSTANTS.SCROLL_SPEED;\n    }\n\n    if (scrollTop < scrollHeight - rect.height && mouseOffset.clientY >= rect.bottom - scrollAreaY) {\n      positionInScrollArea = Math.min(Math.abs(rect.bottom - scrollAreaY - mouseOffset.clientY), scrollAreaY);\n      return positionInScrollArea / scrollAreaY * CONSTANTS.SCROLL_SPEED;\n    }\n\n    return 0;\n  }\n\n  function scrollParentsX(node) {\n    var parent = node.parentNode;\n\n    while (parent && parent !== document) {\n      var rect = parent.getBoundingClientRect();\n      var scrollOffsetX = getScrollOffsetX(rect, parent);\n\n      if (!scrollOffsetX) {\n        scrollParentsX(parent);\n      } else if (scrollOffsetX) {\n        parent.scrollLeft = parent.scrollLeft + scrollOffsetX;\n        return;\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  function scrollParentsY(node) {\n    var parent = node.parentNode;\n\n    while (parent && parent !== document) {\n      var rect = parent.getBoundingClientRect();\n      var scrollOffsetY = getScrollOffsetY(rect, parent);\n\n      if (!scrollOffsetY) {\n        scrollParentsX(parent);\n      } else if (scrollOffsetY) {\n        parent.scrollTop = parent.scrollTop + scrollOffsetY;\n        return;\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  function Store() {\n    var activeGroup = null;\n    var draggedId = null;\n    var placedId = null;\n    var draggedElement = null;\n    var scrollInterval = null;\n    var target = null;\n    var draggedStyle = null;\n    var draggedIndex = -1;\n    var placedIndex = -1;\n    var reorderComponents = {};\n    var reorderGroups = {};\n\n    function autoScroll() {\n      if (target && target.props.autoScroll && target.rootNode) {\n        var rect = target.rootNode.getBoundingClientRect();\n\n        if (target.props.lock !== 'horizontal') {\n          var scrollOffsetX = getScrollOffsetX(rect, target.rootNode);\n\n          if (target.props.autoScrollParents && !scrollOffsetX) {\n            scrollParentsX(target.rootNode);\n          } else if (scrollOffsetX) {\n            target.rootNode.scrollLeft = target.rootNode.scrollLeft + scrollOffsetX;\n          }\n        }\n\n        if (target.props.lock !== 'vertical') {\n          var scrollOffsetY = getScrollOffsetY(rect, target.rootNode);\n\n          if (target.props.autoScrollParents && !scrollOffsetY) {\n            scrollParentsY(target.rootNode);\n          } else if (scrollOffsetY) {\n            target.rootNode.scrollTop = target.rootNode.scrollTop + scrollOffsetY;\n          }\n        }\n      }\n    }\n\n    function getState() {\n      return {\n        draggedId: draggedId,\n        placedId: placedId,\n        activeGroup: activeGroup,\n        draggedStyle: draggedStyle,\n        draggedIndex: draggedIndex,\n        placedIndex: placedIndex,\n        draggedElement: draggedElement\n      };\n    }\n\n    function trigger(clear) {\n      var state = getState();\n\n      if (clear) {\n        for (var i = 0; i < clear.length; i += 1) {\n          state[clear[i]] = null;\n        }\n      }\n\n      reorderComponents[draggedId].setDragState(state);\n    }\n\n    function triggerGroup(clear) {\n      var state = getState();\n\n      if (clear) {\n        for (var i = 0; i < clear.length; i += 1) {\n          state[clear[i]] = null;\n        }\n      }\n\n      for (var reorderId in reorderGroups[activeGroup]) {\n        reorderGroups[activeGroup][reorderId].setDragState(state);\n      }\n    }\n\n    function validateComponentIdAndGroup(reorderId, reorderGroup) {\n      if (typeof reorderId !== 'string') {\n        throw new Error('Expected reorderId to be a string. Instead got ' + typeof reorderId);\n      }\n\n      if (typeof reorderGroup !== 'undefined' && typeof reorderGroup !== 'string') {\n        throw new Error('Expected reorderGroup to be a string. Instead got ' + typeof reorderGroup);\n      }\n    }\n\n    function registerReorderComponent(component) {\n      var reorderId = component.props.reorderId;\n      var reorderGroup = component.props.reorderGroup;\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup in reorderGroups && reorderId in reorderGroups[reorderGroup]) {\n          throw new Error('Duplicate reorderId: ' + reorderId + ' in reorderGroup: ' + reorderGroup);\n        }\n\n        reorderGroups[reorderGroup] = reorderGroups[reorderGroup] || {};\n        reorderGroups[reorderGroup][reorderId] = component;\n      } else {\n        if (reorderId in reorderComponents) {\n          throw new Error('Duplicate reorderId: ' + reorderId);\n        }\n\n        reorderComponents[reorderId] = component;\n      }\n    }\n\n    function unregisterReorderComponent(component) {\n      var reorderId = component.props.reorderId;\n      var reorderGroup = component.props.reorderGroup;\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (!(reorderGroup in reorderGroups)) {\n          throw new Error('Unknown reorderGroup: ' + reorderGroup);\n        }\n\n        if (reorderGroup in reorderGroups && !(reorderId in reorderGroups[reorderGroup])) {\n          throw new Error('Unknown reorderId: ' + reorderId + ' in reorderGroup: ' + reorderGroup);\n        }\n\n        delete reorderGroups[reorderGroup][reorderId];\n      } else {\n        if (!(reorderId in reorderComponents)) {\n          throw new Error('Unknown reorderId: ' + reorderId);\n        }\n\n        delete reorderComponents[reorderId];\n      }\n    }\n\n    function startDrag(reorderId, reorderGroup, index, element, component) {\n      target = component;\n      clearInterval(scrollInterval);\n      scrollInterval = setInterval(autoScroll, CONSTANTS.SCROLL_INTERVAL);\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n      draggedIndex = index;\n      placedIndex = index;\n      draggedStyle = null;\n      draggedElement = element;\n      draggedId = reorderId;\n      placedId = reorderId;\n      activeGroup = null;\n\n      if (typeof reorderGroup !== 'undefined') {\n        activeGroup = reorderGroup;\n        triggerGroup();\n      } else if (draggedId !== null && reorderId === draggedId) {\n        trigger();\n      }\n    }\n\n    function stopDrag(reorderId, reorderGroup) {\n      target = null;\n      clearInterval(scrollInterval);\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (activeGroup !== null) {\n        if (reorderGroup === activeGroup) {\n          draggedIndex = -1;\n          placedIndex = -1;\n          draggedStyle = null;\n          draggedElement = null; // These need to be cleared after trigger to allow state updates to these components\n\n          triggerGroup(['activeGroup']);\n          draggedId = null;\n          placedId = null;\n          activeGroup = null;\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        draggedIndex = -1;\n        placedIndex = -1;\n        draggedStyle = null;\n        draggedElement = null; // These need to be cleared after trigger to allow state updates to these components\n\n        trigger(['activeGroup']);\n        draggedId = null;\n        placedId = null;\n        activeGroup = null;\n      }\n    }\n\n    function setPlacedIndex(reorderId, reorderGroup, index, component) {\n      target = component;\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup === activeGroup) {\n          placedId = reorderId;\n          placedIndex = index;\n          triggerGroup();\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        placedIndex = index;\n        trigger();\n      }\n    }\n\n    function setDraggedStyle(reorderId, reorderGroup, style) {\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup === activeGroup) {\n          draggedStyle = style;\n          triggerGroup();\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        draggedStyle = style;\n        trigger();\n      }\n    }\n\n    this.getState = getState;\n    this.registerReorderComponent = registerReorderComponent;\n    this.unregisterReorderComponent = unregisterReorderComponent;\n    this.startDrag = startDrag;\n    this.stopDrag = stopDrag;\n    this.setPlacedIndex = setPlacedIndex;\n    this.setDraggedStyle = setDraggedStyle;\n  }\n\n  var store = new Store();\n\n  function reorder(list, previousIndex, nextIndex) {\n    var copy = [].concat(list);\n    var item = copy.splice(previousIndex, 1)[0];\n    copy.splice(nextIndex, 0, item);\n    return copy;\n  }\n\n  function reorderImmutable(list, previousIndex, nextIndex) {\n    var item = list.get(previousIndex);\n    return list.delete(previousIndex).splice(nextIndex, 0, item);\n  }\n\n  function reorderFromTo(lists, previousIndex, nextIndex) {\n    var previousList = [].concat(lists.from);\n    var nextList = [].concat(lists.to);\n    var item = previousList.splice(previousIndex, 1)[0];\n    nextList.splice(nextIndex, 0, item);\n    return {\n      from: previousList,\n      to: nextList\n    };\n  }\n\n  function reorderFromToImmutable(lists, previousIndex, nextIndex) {\n    var item = lists.from.get(previousIndex);\n    return {\n      from: lists.from.delete(previousIndex),\n      to: lists.to.splice(nextIndex, 0, item)\n    };\n  }\n\n  function withReorderMethods(Reorder) {\n    Reorder.reorder = reorder;\n    Reorder.reorderImmutable = reorderImmutable;\n    Reorder.reorderFromTo = reorderFromTo;\n    Reorder.reorderFromToImmutable = reorderFromToImmutable;\n    return Reorder;\n  }\n\n  function assign() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (!args.length) {\n      return undefined;\n    }\n\n    if (args.length === 1) {\n      return args[0];\n    }\n\n    var obj = args.shift();\n\n    while (args.length) {\n      var arg = args.shift();\n\n      for (var key in arg) {\n        obj[key] = arg[key];\n      }\n    }\n\n    return obj;\n  }\n\n  function getReorderComponent(React, ReactDOM, createReactClass, PropTypes) {\n    var Reorder = createReactClass({\n      displayName: 'Reorder',\n      getInitialState: function () {\n        return store.getState();\n      },\n      isDragging: function () {\n        return this.state.draggedIndex >= 0;\n      },\n      isPlacing: function () {\n        return this.state.placedIndex >= 0;\n      },\n      isDraggingFrom: function () {\n        return this.props.reorderId === this.state.draggedId;\n      },\n      isPlacingTo: function () {\n        return this.props.reorderId === this.state.placedId;\n      },\n      isInvolvedInDragging: function () {\n        return this.props.reorderId === this.state.draggedId || this.props.reorderGroup === this.state.activeGroup;\n      },\n      preventContextMenu: function (event) {\n        if (downPos && this.props.disableContextMenus) {\n          event.preventDefault();\n        }\n      },\n      preventNativeScrolling: function (event) {\n        event.preventDefault();\n      },\n      persistEvent: function (event) {\n        if (typeof event.persist === 'function') {\n          event.persist();\n        }\n      },\n      copyTouchKeys: function (event) {\n        if (event.touches && event.touches[0]) {\n          this.persistEvent(event);\n          event.clientX = event.touches[0].clientX;\n          event.clientY = event.touches[0].clientY;\n        }\n      },\n      xCollision: function (event, rect) {\n        return event.clientX >= rect.left && event.clientX <= rect.right;\n      },\n      yCollision: function (event, rect) {\n        return event.clientY >= rect.top && event.clientY <= rect.bottom;\n      },\n      findCollisionIndex: function (event, listElements) {\n        for (var i = 0; i < listElements.length; i += 1) {\n          if (!listElements[i].getAttribute('data-placeholder') && !listElements[i].getAttribute('data-dragged')) {\n            var rect = listElements[i].getBoundingClientRect();\n\n            switch (this.props.lock) {\n              case 'horizontal':\n                if (this.yCollision(event, rect)) {\n                  return i;\n                }\n\n                break;\n\n              case 'vertical':\n                if (this.xCollision(event, rect)) {\n                  return i;\n                }\n\n                break;\n\n              default:\n                if (this.yCollision(event, rect) && this.xCollision(event, rect)) {\n                  return i;\n                }\n\n                break;\n            }\n          }\n        }\n\n        return -1;\n      },\n      collidesWithElement: function (event, element) {\n        var rect = element.getBoundingClientRect();\n        return this.yCollision(event, rect) && this.xCollision(event, rect);\n      },\n      getHoldTime: function (event) {\n        if (event.touches && typeof this.props.touchHoldTime !== 'undefined') {\n          return parseInt(this.props.touchHoldTime, 10) || 0;\n        } else if (typeof this.props.mouseHoldTime !== 'undefined') {\n          return parseInt(this.props.mouseHoldTime, 10) || 0;\n        }\n\n        return parseInt(this.props.holdTime, 10) || 0;\n      },\n      startDrag: function (event, target, index) {\n        if (!this.moved) {\n          var rect = target.getBoundingClientRect();\n          var draggedStyle = {\n            position: 'fixed',\n            top: rect.top,\n            left: rect.left,\n            width: rect.width,\n            height: rect.height\n          };\n          store.startDrag(this.props.reorderId, this.props.reorderGroup, index, this.props.children[index], this);\n          store.setDraggedStyle(this.props.reorderId, this.props.reorderGroup, draggedStyle);\n          mouseOffset = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n          mouseDown = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n      },\n      // Begin dragging index, set initial drag style, set placeholder position, calculate mouse offset\n      onItemDown: function (callback, index, event) {\n        if (typeof callback === 'function') {\n          callback(event);\n        }\n\n        if (event.button === 2 || this.props.disabled) {\n          return;\n        }\n\n        this.copyTouchKeys(event);\n        this.moved = false;\n        downPos = {\n          clientX: event.clientX,\n          clientY: event.clientY\n        };\n        var holdTime = this.getHoldTime(event);\n        var target = event.currentTarget;\n\n        if (holdTime) {\n          this.persistEvent(event);\n          this.holdTimeout = setTimeout(this.startDrag.bind(this, event, target, index), holdTime);\n        } else {\n          this.startDrag(event, target, index);\n        }\n      },\n      // Stop dragging - reset style & draggedIndex, handle reorder\n      onWindowUp: function (event) {\n        clearTimeout(this.holdTimeout);\n\n        if (this.isDragging() && this.isDraggingFrom()) {\n          var fromIndex = this.state.draggedIndex;\n          var toIndex = this.state.placedIndex;\n          store.stopDrag(this.props.reorderId, this.props.reorderGroup);\n\n          if (fromIndex >= 0 && (fromIndex !== toIndex || this.state.draggedId !== this.state.placedId) && typeof this.props.onReorder === 'function') {\n            this.props.onReorder(event, fromIndex, toIndex - (this.state.draggedId === this.state.placedId && fromIndex < toIndex ? 1 : 0), this.state.draggedId, this.state.placedId);\n          }\n        }\n\n        downPos = null;\n        mouseOffset = null;\n        mouseDown = null;\n      },\n      // Update dragged position & placeholder index, invalidate drag if moved\n      onWindowMove: function (event) {\n        this.copyTouchKeys(event);\n\n        if (downPos && (Math.abs(event.clientX - downPos.clientX) >= CONSTANTS.HOLD_THRESHOLD || Math.abs(event.clientY - downPos.clientY) >= CONSTANTS.HOLD_THRESHOLD)) {\n          this.moved = true;\n        }\n\n        if (this.isDragging() && this.isInvolvedInDragging()) {\n          this.preventNativeScrolling(event);\n          var element = this.rootNode;\n\n          if (this.collidesWithElement(event, element)) {\n            var children = element.childNodes;\n            var collisionIndex = this.findCollisionIndex(event, children);\n\n            if (collisionIndex <= this.props.children.length && collisionIndex >= 0) {\n              store.setPlacedIndex(this.props.reorderId, this.props.reorderGroup, collisionIndex, this);\n            } else if (typeof this.props.reorderGroup !== 'undefined' && ( // Is part of a group\n            !this.props.children || !this.props.children.length || // If all items removed\n            this.isDraggingFrom() && this.props.children.length === 1 // If dragging back to a now empty list\n            )) {\n              store.setPlacedIndex(this.props.reorderId, this.props.reorderGroup, 0, this);\n            }\n          }\n\n          this.state.draggedStyle.transform = createOffsetStyles(event, this.props);\n          store.setDraggedStyle(this.props.reorderId, this.props.reorderGroup, this.state.draggedStyle);\n          mouseOffset = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n      },\n      setDragState: function (state) {\n        var isPartOfGroup = this.props.reorderGroup;\n        var isGroupDragged = state.activeGroup;\n        var storedActiveGroup = this.state.activeGroup;\n        var wasGroupDragged = !isGroupDragged && storedActiveGroup;\n        var isActiveGroup = isPartOfGroup && isGroupDragged && state.activeGroup === this.props.reorderGroup;\n        var isDragged = this.props.reorderId === state.draggedId;\n        var isPlaced = this.props.reorderId === state.placedId;\n        var wasPlaced = this.props.reorderId === this.state.placedId; // This check is like a shouldComponentUpdate but specific to our store state\n        // Allowing prop changes to update the component\n\n        if (!isGroupDragged && !isPartOfGroup && (isDragged || isPlaced) || isPartOfGroup && (!storedActiveGroup || wasGroupDragged) || wasGroupDragged || isActiveGroup && (isDragged || isPlaced || wasPlaced)) {\n          this.setState(state);\n        }\n      },\n      // Add listeners and store root node\n      componentDidMount: function () {\n        store.registerReorderComponent(this);\n        window.addEventListener('mouseup', this.onWindowUp, {\n          passive: false\n        });\n        window.addEventListener('touchend', this.onWindowUp, {\n          passive: false\n        });\n        window.addEventListener('mousemove', this.onWindowMove, {\n          passive: false\n        });\n        window.addEventListener('touchmove', this.onWindowMove, {\n          passive: false\n        });\n        window.addEventListener('contextmenu', this.preventContextMenu, {\n          passive: false\n        });\n        this.storeRootNode();\n      },\n      // Remove listeners\n      componentWillUnmount: function () {\n        store.unregisterReorderComponent(this);\n        clearTimeout(this.holdTimeout);\n        window.removeEventListener('mouseup', this.onWindowUp);\n        window.removeEventListener('touchend', this.onWindowUp);\n        window.removeEventListener('mousemove', this.onWindowMove);\n        window.removeEventListener('touchmove', this.onWindowMove);\n        window.removeEventListener('contextmenu', this.preventContextMenu);\n      },\n      storeRootNode: function () {\n        var element = ReactDOM.findDOMNode(this);\n        this.rootNode = element;\n\n        if (typeof this.props.getRef === 'function') {\n          this.props.getRef(element);\n        }\n      },\n      render: function () {\n        var children = this.props.children && this.props.children.map(function (child, index) {\n          var isDragged = this.isDragging() && this.isDraggingFrom() && index === this.state.draggedIndex;\n          var draggedStyle = isDragged ? assign({}, child.props.style, this.state.draggedStyle) : child.props.style;\n          var draggedClass = [child.props.className || '', isDragged ? this.props.draggedClassName : ''].join(' ');\n          return React.cloneElement(isDragged ? this.state.draggedElement : child, {\n            style: draggedStyle,\n            className: draggedClass,\n            onMouseDown: this.onItemDown.bind(this, child.props.onMouseDown, index),\n            onTouchStart: this.onItemDown.bind(this, child.props.onTouchStart, index),\n            'data-dragged': isDragged ? true : null\n          });\n        }.bind(this));\n        var placeholderElement = this.props.placeholder || this.state.draggedElement;\n\n        if (this.isPlacing() && this.isPlacingTo() && placeholderElement) {\n          var placeholder = React.cloneElement(placeholderElement, {\n            key: 'react-reorder-placeholder',\n            className: [placeholderElement.props.className || '', this.props.placeholderClassName].join(' '),\n            'data-placeholder': true\n          });\n          children.splice(this.state.placedIndex, 0, placeholder);\n        }\n\n        return React.createElement(this.props.component, {\n          className: this.props.className,\n          id: this.props.id,\n          style: this.props.style,\n          onClick: this.props.onClick\n        }, children);\n      }\n    });\n    Reorder.propTypes = {\n      component: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n      getRef: PropTypes.func,\n      reorderId: PropTypes.string,\n      reorderGroup: PropTypes.string,\n      placeholderClassName: PropTypes.string,\n      draggedClassName: PropTypes.string,\n      lock: PropTypes.string,\n      holdTime: PropTypes.number,\n      touchHoldTime: PropTypes.number,\n      mouseHoldTime: PropTypes.number,\n      onReorder: PropTypes.func,\n      placeholder: PropTypes.element,\n      autoScroll: PropTypes.bool,\n      autoScrollParents: PropTypes.bool,\n      disabled: PropTypes.bool,\n      disableContextMenus: PropTypes.bool\n    };\n    Reorder.defaultProps = {\n      component: 'div',\n      // getRef: function,\n      // reorderId: id,\n      // reorderGroup: group,\n      placeholderClassName: 'placeholder',\n      draggedClassName: 'dragged',\n      // lock: direction,\n      holdTime: 0,\n      // touchHoldTime: 0,\n      // mouseHoldTime: 0,\n      // onReorder: function,\n      // placeholder: react element\n      autoScroll: true,\n      autoScrollParents: true,\n      disabled: false,\n      disableContextMenus: true\n    };\n    return Reorder;\n  }\n  /* istanbul ignore next */\n  // Export for commonjs / browserify\n\n\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    var React = require('react'); // eslint-disable-line no-undef\n\n\n    var ReactDOM = require('react-dom'); // eslint-disable-line no-undef\n\n\n    var createReactClass = require('create-react-class'); // eslint-disable-line no-undef\n\n\n    var PropTypes = require('prop-types'); // eslint-disable-line no-undef\n\n\n    module.exports = withReorderMethods( // eslint-disable-line no-undef\n    getReorderComponent(React, ReactDOM, createReactClass, PropTypes)); // Export for amd / require\n  } else if (typeof define === 'function' && define.amd) {\n    // eslint-disable-line no-undef\n    define( // eslint-disable-line no-undef\n    ['react', 'react-dom', 'create-react-class', 'prop-types'], function (ReactAMD, ReactDOMAMD, createReactClassAMD, PropTypesAMD) {\n      return withReorderMethods(getReorderComponent(ReactAMD, ReactDOMAMD, createReactClassAMD, PropTypesAMD));\n    }); // Export globally\n  } else {\n    var root;\n\n    if (typeof window !== 'undefined') {\n      root = window;\n    } else if (typeof global !== 'undefined') {\n      root = global; // eslint-disable-line no-undef\n    } else if (typeof self !== 'undefined') {\n      root = self; // eslint-disable-line no-undef\n    } else {\n      root = this;\n    }\n\n    root.Reorder = withReorderMethods(getReorderComponent(root.React, root.ReactDOM, root.createReactClass, root.PropTypes));\n  }\n})();","map":{"version":3,"sources":["/Users/razbasnet/Documents/react/GitHub/simple-to-do/node_modules/react-reorder/src/index.js"],"names":["CONSTANTS","HOLD_THRESHOLD","SCROLL_INTERVAL","SCROLL_AREA_MAX","SCROLL_SPEED","downPos","mouseOffset","mouseDown","createOffsetStyles","event","props","top","lock","clientY","left","clientX","getScrollOffsetX","rect","node","positionInScrollArea","scrollLeft","scrollWidth","scrollAreaX","Math","min","width","abs","right","getScrollOffsetY","scrollTop","scrollHeight","scrollAreaY","height","bottom","scrollParentsX","parent","parentNode","document","getBoundingClientRect","scrollOffsetX","scrollParentsY","scrollOffsetY","Store","activeGroup","draggedId","placedId","draggedElement","scrollInterval","target","draggedStyle","draggedIndex","placedIndex","reorderComponents","reorderGroups","autoScroll","rootNode","autoScrollParents","getState","trigger","clear","state","i","length","setDragState","triggerGroup","reorderId","validateComponentIdAndGroup","reorderGroup","Error","registerReorderComponent","component","unregisterReorderComponent","startDrag","index","element","clearInterval","setInterval","stopDrag","setPlacedIndex","setDraggedStyle","style","store","reorder","list","previousIndex","nextIndex","copy","concat","item","splice","reorderImmutable","get","delete","reorderFromTo","lists","previousList","from","nextList","to","reorderFromToImmutable","withReorderMethods","Reorder","assign","args","Array","prototype","slice","call","arguments","undefined","obj","shift","arg","key","getReorderComponent","React","ReactDOM","createReactClass","PropTypes","displayName","getInitialState","isDragging","isPlacing","isDraggingFrom","isPlacingTo","isInvolvedInDragging","preventContextMenu","disableContextMenus","preventDefault","preventNativeScrolling","persistEvent","persist","copyTouchKeys","touches","xCollision","yCollision","findCollisionIndex","listElements","getAttribute","collidesWithElement","getHoldTime","touchHoldTime","parseInt","mouseHoldTime","holdTime","moved","position","children","onItemDown","callback","button","disabled","currentTarget","holdTimeout","setTimeout","bind","onWindowUp","clearTimeout","fromIndex","toIndex","onReorder","onWindowMove","childNodes","collisionIndex","transform","isPartOfGroup","isGroupDragged","storedActiveGroup","wasGroupDragged","isActiveGroup","isDragged","isPlaced","wasPlaced","setState","componentDidMount","window","addEventListener","passive","storeRootNode","componentWillUnmount","removeEventListener","findDOMNode","getRef","render","map","child","draggedClass","className","draggedClassName","join","cloneElement","onMouseDown","onTouchStart","placeholderElement","placeholder","placeholderClassName","createElement","id","onClick","propTypes","oneOfType","func","string","number","bool","defaultProps","exports","module","require","define","amd","ReactAMD","ReactDOMAMD","createReactClassAMD","PropTypesAMD","root","global","self"],"mappings":"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","sourcesContent":["'use strict';\n\n(function () {\n\n  var CONSTANTS = {\n    HOLD_THRESHOLD: 8,\n    SCROLL_INTERVAL: 1000 / 60,\n    SCROLL_AREA_MAX: 50,\n    SCROLL_SPEED: 20\n  };\n\n  var downPos = null;\n  var mouseOffset = null;\n  var mouseDown = null;\n\n  function createOffsetStyles (event, props) {\n    var top = (!props.lock || props.lock === 'horizontal') ? mouseOffset.clientY - mouseDown.clientY : 0;\n    var left = (!props.lock || props.lock === 'vertical') ? mouseOffset.clientX - mouseDown.clientX : 0;\n\n    return 'translate(' + left + 'px,' + top + 'px)';\n  }\n\n  function getScrollOffsetX (rect, node) {\n    var positionInScrollArea;\n    var scrollLeft = node.scrollLeft;\n    var scrollWidth = node.scrollWidth;\n\n    var scrollAreaX = Math.min(rect.width / 3, CONSTANTS.SCROLL_AREA_MAX);\n\n    if (scrollLeft > 0 && mouseOffset.clientX <= rect.left + scrollAreaX) {\n      positionInScrollArea = Math.min(Math.abs(rect.left + scrollAreaX - mouseOffset.clientX), scrollAreaX);\n      return -positionInScrollArea / scrollAreaX * CONSTANTS.SCROLL_SPEED;\n    }\n\n    if (scrollLeft < scrollWidth - rect.width && mouseOffset.clientX >= rect.right - scrollAreaX) {\n      positionInScrollArea = Math.min(Math.abs(rect.right - scrollAreaX - mouseOffset.clientX), scrollAreaX);\n      return positionInScrollArea / scrollAreaX * CONSTANTS.SCROLL_SPEED;\n    }\n\n    return 0;\n  }\n\n  function getScrollOffsetY (rect, node) {\n    var positionInScrollArea;\n    var scrollTop = node.scrollTop;\n    var scrollHeight = node.scrollHeight;\n\n    var scrollAreaY = Math.min(rect.height / 3, CONSTANTS.SCROLL_AREA_MAX);\n\n    if (scrollTop > 0 && mouseOffset.clientY <= rect.top + scrollAreaY) {\n      positionInScrollArea = Math.min(Math.abs(rect.top + scrollAreaY - mouseOffset.clientY), scrollAreaY);\n      return -positionInScrollArea / scrollAreaY * CONSTANTS.SCROLL_SPEED;\n    }\n\n    if (scrollTop < scrollHeight - rect.height && mouseOffset.clientY >= rect.bottom - scrollAreaY) {\n      positionInScrollArea = Math.min(Math.abs(rect.bottom - scrollAreaY - mouseOffset.clientY), scrollAreaY);\n      return positionInScrollArea / scrollAreaY * CONSTANTS.SCROLL_SPEED;\n    }\n\n    return 0;\n  }\n\n  function scrollParentsX (node) {\n    var parent = node.parentNode;\n\n    while (parent && parent !== document) {\n      var rect = parent.getBoundingClientRect();\n\n      var scrollOffsetX = getScrollOffsetX(rect, parent);\n\n      if (!scrollOffsetX) {\n        scrollParentsX(parent);\n      } else if (scrollOffsetX) {\n        parent.scrollLeft = parent.scrollLeft + scrollOffsetX;\n        return;\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  function scrollParentsY (node) {\n    var parent = node.parentNode;\n\n    while (parent && parent !== document) {\n      var rect = parent.getBoundingClientRect();\n\n      var scrollOffsetY = getScrollOffsetY(rect, parent);\n\n      if (!scrollOffsetY) {\n        scrollParentsX(parent);\n      } else if (scrollOffsetY) {\n        parent.scrollTop = parent.scrollTop + scrollOffsetY;\n        return;\n      }\n\n      parent = parent.parentNode;\n    }\n  }\n\n  function Store () {\n    var activeGroup = null;\n    var draggedId = null;\n    var placedId = null;\n    var draggedElement = null;\n    var scrollInterval = null;\n    var target = null;\n\n    var draggedStyle = null;\n    var draggedIndex = -1;\n    var placedIndex = -1;\n\n    var reorderComponents = {};\n    var reorderGroups = {};\n\n    function autoScroll () {\n      if (target && target.props.autoScroll && target.rootNode) {\n        var rect = target.rootNode.getBoundingClientRect();\n\n        if (target.props.lock !== 'horizontal') {\n          var scrollOffsetX = getScrollOffsetX(rect, target.rootNode);\n\n          if (target.props.autoScrollParents && !scrollOffsetX) {\n            scrollParentsX(target.rootNode);\n          } else if (scrollOffsetX) {\n            target.rootNode.scrollLeft = target.rootNode.scrollLeft + scrollOffsetX;\n          }\n        }\n\n        if (target.props.lock !== 'vertical') {\n          var scrollOffsetY = getScrollOffsetY(rect, target.rootNode);\n\n          if (target.props.autoScrollParents && !scrollOffsetY) {\n            scrollParentsY(target.rootNode);\n          } else if (scrollOffsetY) {\n            target.rootNode.scrollTop = target.rootNode.scrollTop + scrollOffsetY;\n          }\n        }\n      }\n    }\n\n    function getState () {\n      return {\n        draggedId: draggedId,\n        placedId: placedId,\n        activeGroup: activeGroup,\n        draggedStyle: draggedStyle,\n        draggedIndex: draggedIndex,\n        placedIndex: placedIndex,\n        draggedElement: draggedElement\n      };\n    }\n\n    function trigger (clear) {\n      var state = getState();\n\n      if (clear) {\n        for (var i = 0; i < clear.length; i += 1) {\n          state[clear[i]] = null;\n        }\n      }\n\n      reorderComponents[draggedId].setDragState(state);\n    }\n\n    function triggerGroup (clear) {\n      var state = getState();\n\n      if (clear) {\n        for (var i = 0; i < clear.length; i += 1) {\n          state[clear[i]] = null;\n        }\n      }\n\n      for (var reorderId in reorderGroups[activeGroup]) {\n        reorderGroups[activeGroup][reorderId].setDragState(state);\n      }\n    }\n\n    function validateComponentIdAndGroup (reorderId, reorderGroup) {\n      if (typeof reorderId !== 'string') {\n        throw new Error('Expected reorderId to be a string. Instead got ' + (typeof reorderId));\n      }\n\n      if (typeof reorderGroup !== 'undefined' && typeof reorderGroup !== 'string') {\n        throw new Error('Expected reorderGroup to be a string. Instead got ' + (typeof reorderGroup));\n      }\n    }\n\n    function registerReorderComponent (component) {\n      var reorderId = component.props.reorderId;\n      var reorderGroup = component.props.reorderGroup;\n\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if ((reorderGroup in reorderGroups) && (reorderId in reorderGroups[reorderGroup])) {\n          throw new Error('Duplicate reorderId: ' + reorderId + ' in reorderGroup: ' + reorderGroup);\n        }\n\n        reorderGroups[reorderGroup] = reorderGroups[reorderGroup] || {};\n        reorderGroups[reorderGroup][reorderId] = component;\n      } else {\n        if (reorderId in reorderComponents) {\n          throw new Error('Duplicate reorderId: ' + reorderId);\n        }\n\n        reorderComponents[reorderId] = component;\n      }\n    }\n\n    function unregisterReorderComponent (component) {\n      var reorderId = component.props.reorderId;\n      var reorderGroup = component.props.reorderGroup;\n\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (!(reorderGroup in reorderGroups)) {\n          throw new Error('Unknown reorderGroup: ' + reorderGroup);\n        }\n\n        if ((reorderGroup in reorderGroups) && !(reorderId in reorderGroups[reorderGroup])) {\n          throw new Error('Unknown reorderId: ' + reorderId + ' in reorderGroup: ' + reorderGroup);\n        }\n\n        delete reorderGroups[reorderGroup][reorderId];\n      } else {\n        if (!(reorderId in reorderComponents)) {\n          throw new Error('Unknown reorderId: ' + reorderId);\n        }\n\n        delete reorderComponents[reorderId];\n      }\n    }\n\n    function startDrag (reorderId, reorderGroup, index, element, component) {\n      target = component;\n\n      clearInterval(scrollInterval);\n      scrollInterval = setInterval(autoScroll, CONSTANTS.SCROLL_INTERVAL);\n\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      draggedIndex = index;\n      placedIndex = index;\n      draggedStyle = null;\n      draggedElement = element;\n\n      draggedId = reorderId;\n      placedId = reorderId;\n      activeGroup = null;\n\n      if (typeof reorderGroup !== 'undefined') {\n        activeGroup = reorderGroup;\n\n        triggerGroup();\n      } else if (draggedId !== null && reorderId === draggedId) {\n        trigger();\n      }\n    }\n\n    function stopDrag (reorderId, reorderGroup) {\n      target = null;\n\n      clearInterval(scrollInterval);\n\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (activeGroup !== null) {\n        if (reorderGroup === activeGroup) {\n          draggedIndex = -1;\n          placedIndex = -1;\n          draggedStyle = null;\n          draggedElement = null;\n\n          // These need to be cleared after trigger to allow state updates to these components\n          triggerGroup(['activeGroup']);\n\n          draggedId = null;\n          placedId = null;\n          activeGroup = null;\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        draggedIndex = -1;\n        placedIndex = -1;\n        draggedStyle = null;\n        draggedElement = null;\n\n        // These need to be cleared after trigger to allow state updates to these components\n        trigger(['activeGroup']);\n\n        draggedId = null;\n        placedId = null;\n        activeGroup = null;\n      }\n    }\n\n    function setPlacedIndex (reorderId, reorderGroup, index, component) {\n      target = component;\n\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup === activeGroup) {\n          placedId = reorderId;\n          placedIndex = index;\n\n          triggerGroup();\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        placedIndex = index;\n\n        trigger();\n      }\n    }\n\n    function setDraggedStyle (reorderId, reorderGroup, style) {\n      validateComponentIdAndGroup(reorderId, reorderGroup);\n\n      if (typeof reorderGroup !== 'undefined') {\n        if (reorderGroup === activeGroup) {\n          draggedStyle = style;\n\n          triggerGroup();\n        }\n      } else if (draggedId !== null && reorderId === draggedId) {\n        draggedStyle = style;\n\n        trigger();\n      }\n    }\n\n    this.getState = getState;\n    this.registerReorderComponent = registerReorderComponent;\n    this.unregisterReorderComponent = unregisterReorderComponent;\n    this.startDrag = startDrag;\n    this.stopDrag = stopDrag;\n    this.setPlacedIndex = setPlacedIndex;\n    this.setDraggedStyle = setDraggedStyle;\n  }\n\n  var store = new Store();\n\n  function reorder (list, previousIndex, nextIndex) {\n    var copy = [].concat(list);\n    var item = copy.splice(previousIndex, 1)[0];\n\n    copy.splice(nextIndex, 0, item);\n\n    return copy;\n  }\n\n  function reorderImmutable (list, previousIndex, nextIndex) {\n    var item = list.get(previousIndex);\n    return list.delete(previousIndex).splice(nextIndex, 0, item);\n  }\n\n  function reorderFromTo (lists, previousIndex, nextIndex) {\n    var previousList = [].concat(lists.from);\n    var nextList = [].concat(lists.to);\n\n    var item = previousList.splice(previousIndex, 1)[0];\n    nextList.splice(nextIndex, 0, item);\n\n    return {\n      from: previousList,\n      to: nextList\n    };\n  }\n\n  function reorderFromToImmutable (lists, previousIndex, nextIndex) {\n    var item = lists.from.get(previousIndex);\n\n    return {\n      from: lists.from.delete(previousIndex),\n      to: lists.to.splice(nextIndex, 0, item)\n    };\n  }\n\n  function withReorderMethods (Reorder) {\n    Reorder.reorder = reorder;\n    Reorder.reorderImmutable = reorderImmutable;\n    Reorder.reorderFromTo = reorderFromTo;\n    Reorder.reorderFromToImmutable = reorderFromToImmutable;\n    return Reorder;\n  }\n\n  function assign () {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (!args.length) {\n      return undefined;\n    }\n\n    if (args.length === 1) {\n      return args[0];\n    }\n\n    var obj = args.shift();\n\n    while (args.length) {\n      var arg = args.shift();\n\n      for (var key in arg) {\n        obj[key] = arg[key];\n      }\n    }\n\n    return obj;\n  }\n\n  function getReorderComponent (React, ReactDOM, createReactClass, PropTypes) {\n\n    var Reorder = createReactClass({\n      displayName: 'Reorder',\n\n      getInitialState: function () {\n        return store.getState();\n      },\n\n      isDragging: function () {\n        return this.state.draggedIndex >= 0;\n      },\n\n      isPlacing: function () {\n        return this.state.placedIndex >= 0;\n      },\n\n      isDraggingFrom: function () {\n        return this.props.reorderId === this.state.draggedId;\n      },\n\n      isPlacingTo: function () {\n        return this.props.reorderId === this.state.placedId;\n      },\n\n      isInvolvedInDragging: function () {\n        return this.props.reorderId === this.state.draggedId || this.props.reorderGroup === this.state.activeGroup;\n      },\n\n      preventContextMenu: function (event) {\n        if (downPos && this.props.disableContextMenus) {\n          event.preventDefault();\n        }\n      },\n\n      preventNativeScrolling: function (event) {\n        event.preventDefault();\n      },\n\n      persistEvent: function (event) {\n        if (typeof event.persist === 'function') {\n          event.persist();\n        }\n      },\n\n      copyTouchKeys: function (event) {\n        if (event.touches && event.touches[0]) {\n          this.persistEvent(event);\n\n          event.clientX = event.touches[0].clientX;\n          event.clientY = event.touches[0].clientY;\n        }\n      },\n\n      xCollision: function (event, rect) {\n        return event.clientX >= rect.left && event.clientX <= rect.right;\n      },\n\n      yCollision: function (event, rect) {\n        return event.clientY >= rect.top && event.clientY <= rect.bottom;\n      },\n\n      findCollisionIndex: function (event, listElements) {\n        for (var i = 0; i < listElements.length; i += 1) {\n          if (!listElements[i].getAttribute('data-placeholder') && !listElements[i].getAttribute('data-dragged')) {\n\n            var rect = listElements[i].getBoundingClientRect();\n\n            switch (this.props.lock) {\n              case 'horizontal':\n                if (this.yCollision(event, rect)) {\n                  return i;\n                }\n                break;\n              case 'vertical':\n                if (this.xCollision(event, rect)) {\n                  return i;\n                }\n                break;\n              default:\n                if (this.yCollision(event, rect) && this.xCollision(event, rect)) {\n                  return i;\n                }\n                break;\n            }\n\n          }\n\n        }\n\n        return -1;\n      },\n\n      collidesWithElement: function (event, element) {\n        var rect = element.getBoundingClientRect();\n        return this.yCollision(event, rect) && this.xCollision(event, rect);\n      },\n\n      getHoldTime: function (event) {\n        if (event.touches && typeof this.props.touchHoldTime !== 'undefined') {\n          return parseInt(this.props.touchHoldTime, 10) || 0;\n        } else if (typeof this.props.mouseHoldTime !== 'undefined') {\n          return parseInt(this.props.mouseHoldTime, 10) || 0;\n        }\n\n        return parseInt(this.props.holdTime, 10) || 0;\n      },\n\n      startDrag: function (event, target, index) {\n        if (!this.moved) {\n          var rect = target.getBoundingClientRect();\n\n          var draggedStyle = {\n            position: 'fixed',\n            top: rect.top,\n            left: rect.left,\n            width: rect.width,\n            height: rect.height\n          };\n\n          store.startDrag(this.props.reorderId, this.props.reorderGroup, index, this.props.children[index], this);\n          store.setDraggedStyle(this.props.reorderId, this.props.reorderGroup, draggedStyle);\n\n          mouseOffset = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n\n          mouseDown = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n      },\n\n      // Begin dragging index, set initial drag style, set placeholder position, calculate mouse offset\n      onItemDown: function (callback, index, event) {\n        if (typeof callback === 'function') {\n          callback(event);\n        }\n\n        if (event.button === 2 || this.props.disabled) {\n          return;\n        }\n\n        this.copyTouchKeys(event);\n\n        this.moved = false;\n        downPos = {\n          clientX: event.clientX,\n          clientY: event.clientY\n        };\n\n        var holdTime = this.getHoldTime(event);\n        var target = event.currentTarget;\n\n        if (holdTime) {\n          this.persistEvent(event);\n          this.holdTimeout = setTimeout(this.startDrag.bind(this, event, target, index), holdTime);\n        } else {\n          this.startDrag(event, target, index);\n        }\n      },\n\n      // Stop dragging - reset style & draggedIndex, handle reorder\n      onWindowUp: function (event) {\n        clearTimeout(this.holdTimeout);\n\n        if (this.isDragging() && this.isDraggingFrom()) {\n          var fromIndex = this.state.draggedIndex;\n          var toIndex = this.state.placedIndex;\n\n          store.stopDrag(this.props.reorderId, this.props.reorderGroup);\n\n          if (\n            fromIndex >= 0 &&\n            (fromIndex !== toIndex || this.state.draggedId !== this.state.placedId) &&\n            typeof this.props.onReorder === 'function'\n          ) {\n            this.props.onReorder(\n              event,\n              fromIndex,\n              toIndex - (this.state.draggedId === this.state.placedId && fromIndex < toIndex ? 1 : 0),\n              this.state.draggedId,\n              this.state.placedId\n            );\n          }\n        }\n\n        downPos = null;\n        mouseOffset = null;\n        mouseDown = null;\n      },\n\n      // Update dragged position & placeholder index, invalidate drag if moved\n      onWindowMove: function (event) {\n        this.copyTouchKeys(event);\n\n        if (\n          downPos && (\n            Math.abs(event.clientX - downPos.clientX) >= CONSTANTS.HOLD_THRESHOLD ||\n            Math.abs(event.clientY - downPos.clientY) >= CONSTANTS.HOLD_THRESHOLD\n          )\n        ) {\n          this.moved = true;\n        }\n\n        if (this.isDragging() && this.isInvolvedInDragging()) {\n          this.preventNativeScrolling(event);\n\n          var element = this.rootNode;\n\n          if (this.collidesWithElement(event, element)) {\n\n            var children = element.childNodes;\n            var collisionIndex = this.findCollisionIndex(event, children);\n\n            if (\n              collisionIndex <= this.props.children.length &&\n              collisionIndex >= 0\n            ) {\n              store.setPlacedIndex(this.props.reorderId, this.props.reorderGroup, collisionIndex, this);\n            } else if (\n              typeof this.props.reorderGroup !== 'undefined' && // Is part of a group\n              (\n                (!this.props.children || !this.props.children.length) || // If all items removed\n                (this.isDraggingFrom() && this.props.children.length === 1) // If dragging back to a now empty list\n              )\n            ) {\n              store.setPlacedIndex(this.props.reorderId, this.props.reorderGroup, 0, this);\n            }\n\n          }\n\n          this.state.draggedStyle.transform = createOffsetStyles(event, this.props);\n          store.setDraggedStyle(this.props.reorderId, this.props.reorderGroup, this.state.draggedStyle);\n\n          mouseOffset = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n      },\n\n      setDragState: function (state) {\n        var isPartOfGroup = this.props.reorderGroup;\n        var isGroupDragged = state.activeGroup;\n        var storedActiveGroup = this.state.activeGroup;\n\n        var wasGroupDragged = !isGroupDragged && storedActiveGroup;\n\n        var isActiveGroup = isPartOfGroup && isGroupDragged &&\n          state.activeGroup === this.props.reorderGroup;\n\n        var isDragged = this.props.reorderId === state.draggedId;\n        var isPlaced = this.props.reorderId === state.placedId;\n        var wasPlaced = this.props.reorderId === this.state.placedId;\n\n        // This check is like a shouldComponentUpdate but specific to our store state\n        // Allowing prop changes to update the component\n        if (\n          (!isGroupDragged && !isPartOfGroup && (isDragged || isPlaced)) ||\n          (isPartOfGroup && (!storedActiveGroup || wasGroupDragged)) ||\n          wasGroupDragged ||\n          (isActiveGroup && (isDragged || isPlaced || wasPlaced))\n        ) {\n          this.setState(state);\n        }\n      },\n\n      // Add listeners and store root node\n      componentDidMount: function () {\n        store.registerReorderComponent(this);\n        window.addEventListener('mouseup', this.onWindowUp, {passive: false});\n        window.addEventListener('touchend', this.onWindowUp, {passive: false});\n        window.addEventListener('mousemove', this.onWindowMove, {passive: false});\n        window.addEventListener('touchmove', this.onWindowMove, {passive: false});\n        window.addEventListener('contextmenu', this.preventContextMenu, {passive: false});\n        this.storeRootNode();\n      },\n\n      // Remove listeners\n      componentWillUnmount: function () {\n        store.unregisterReorderComponent(this);\n        clearTimeout(this.holdTimeout);\n\n        window.removeEventListener('mouseup', this.onWindowUp);\n        window.removeEventListener('touchend', this.onWindowUp);\n        window.removeEventListener('mousemove', this.onWindowMove);\n        window.removeEventListener('touchmove', this.onWindowMove);\n        window.removeEventListener('contextmenu', this.preventContextMenu);\n      },\n\n      storeRootNode: function () {\n        var element = ReactDOM.findDOMNode(this);\n        this.rootNode = element;\n\n        if (typeof this.props.getRef === 'function') {\n          this.props.getRef(element);\n        }\n      },\n\n      render: function () {\n        var children = this.props.children && this.props.children.map(function (child, index) {\n          var isDragged = this.isDragging() && this.isDraggingFrom() && index === this.state.draggedIndex;\n\n          var draggedStyle = isDragged ? assign({}, child.props.style, this.state.draggedStyle) : child.props.style;\n\n          var draggedClass = [\n            child.props.className || '',\n            (isDragged ? this.props.draggedClassName : '')\n          ].join(' ');\n\n          return React.cloneElement(\n            isDragged ? this.state.draggedElement : child,\n            {\n              style: draggedStyle,\n              className: draggedClass,\n              onMouseDown: this.onItemDown.bind(this, child.props.onMouseDown, index),\n              onTouchStart: this.onItemDown.bind(this, child.props.onTouchStart, index),\n              'data-dragged': isDragged ? true : null\n            }\n          );\n        }.bind(this));\n\n        var placeholderElement = this.props.placeholder || this.state.draggedElement;\n\n        if (this.isPlacing() && this.isPlacingTo() && placeholderElement) {\n          var placeholder = React.cloneElement(\n            placeholderElement,\n            {\n              key: 'react-reorder-placeholder',\n              className: [placeholderElement.props.className || '', this.props.placeholderClassName].join(' '),\n              'data-placeholder': true\n            }\n          );\n\n          children.splice(this.state.placedIndex, 0, placeholder);\n        }\n\n        return React.createElement(\n          this.props.component,\n          {\n            className: this.props.className,\n            id: this.props.id,\n            style: this.props.style,\n            onClick: this.props.onClick\n          },\n          children\n        );\n      }\n\n    });\n\n    Reorder.propTypes = {\n      component: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n      getRef: PropTypes.func,\n      reorderId: PropTypes.string,\n      reorderGroup: PropTypes.string,\n      placeholderClassName: PropTypes.string,\n      draggedClassName: PropTypes.string,\n      lock: PropTypes.string,\n      holdTime: PropTypes.number,\n      touchHoldTime: PropTypes.number,\n      mouseHoldTime: PropTypes.number,\n      onReorder: PropTypes.func,\n      placeholder: PropTypes.element,\n      autoScroll: PropTypes.bool,\n      autoScrollParents: PropTypes.bool,\n      disabled: PropTypes.bool,\n      disableContextMenus: PropTypes.bool\n    };\n\n    Reorder.defaultProps = {\n      component: 'div',\n      // getRef: function,\n      // reorderId: id,\n      // reorderGroup: group,\n      placeholderClassName: 'placeholder',\n      draggedClassName: 'dragged',\n      // lock: direction,\n      holdTime: 0,\n      // touchHoldTime: 0,\n      // mouseHoldTime: 0,\n      // onReorder: function,\n      // placeholder: react element\n      autoScroll: true,\n      autoScrollParents: true,\n      disabled: false,\n      disableContextMenus: true\n    };\n\n    return Reorder;\n\n  }\n\n  /* istanbul ignore next */\n\n  // Export for commonjs / browserify\n  if (typeof exports === 'object' && typeof module !== 'undefined') {\n    var React = require('react'); // eslint-disable-line no-undef\n    var ReactDOM = require('react-dom'); // eslint-disable-line no-undef\n    var createReactClass = require('create-react-class'); // eslint-disable-line no-undef\n    var PropTypes = require('prop-types'); // eslint-disable-line no-undef\n    module.exports = withReorderMethods( // eslint-disable-line no-undef\n      getReorderComponent(React, ReactDOM, createReactClass, PropTypes)\n    );\n  // Export for amd / require\n  } else if (typeof define === 'function' && define.amd) { // eslint-disable-line no-undef\n    define( // eslint-disable-line no-undef\n      ['react', 'react-dom', 'create-react-class', 'prop-types'],\n      function (ReactAMD, ReactDOMAMD, createReactClassAMD, PropTypesAMD) {\n        return withReorderMethods(\n          getReorderComponent(ReactAMD, ReactDOMAMD, createReactClassAMD, PropTypesAMD)\n        );\n      }\n    );\n  // Export globally\n  } else {\n    var root;\n\n    if (typeof window !== 'undefined') {\n      root = window;\n    } else if (typeof global !== 'undefined') {\n      root = global; // eslint-disable-line no-undef\n    } else if (typeof self !== 'undefined') {\n      root = self; // eslint-disable-line no-undef\n    } else {\n      root = this;\n    }\n\n    root.Reorder = withReorderMethods(\n      getReorderComponent(root.React, root.ReactDOM, root.createReactClass, root.PropTypes)\n    );\n  }\n\n})();\n"]},"metadata":{},"sourceType":"script"}